## 1. Redis持久化

> ***面试官：知道Redis持久化吗？***

嗯嗯知道的，Redis提供了RDB持久化、AOF持久化。

前者是保存了整个Redis**数据库状态**、而后者是保存了从Redis启动后所有执行的命令。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/7c3207fab258409a86d5f04eb45a9bea.png#pic_center)

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/22c12890182149f18280de79f17bec79.png#pic_center)


> <br/>
>
> *面试官思考中…*
>
> <br/>

### 1.1 生成RDB文件的命令

> ***面试官：那你说一说Redis生成RDB文件的命令是什么？***

好的，有两个，一个是SAVE命令，一个是BGSAVE命令。

> <br/>
>
> *面试官思考中…*
>
> <br/>

### 1.2 两种命令的选择

> ***面试官：是你的话，你会在什么场景使用什么命令？***

是这样的，SAVE命令会**阻塞**Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求。

而BGSAVE命令则**不进行阻塞**，它会派生出一个子进程，然后由**子进程**负责创建RDB文件，服务器进程继续处理命令请求。

如果是在**业务高峰期**的话要使用RDB的保存命令，建议是使用后者，可以防止某些请求丢失了。

> <br/>
>
> *面试官思考中…*
>
> <br/>

## 2. AOF重写

> ***面试官：知道AOF文件重写吗？***

嗯嗯知道的。AOF文件重写主要是为了解决**AOF文件体积膨胀**的问题。

对于一个键值对，AOF旧的文件会保存数十条对该键值对的修改命令，这样浪费了大量内存空间。

而AOF文件重写主要是可以创建一个新的AOF文件来**替代**现有的AOF文件，新旧两个AOF文件所保存的数据库状态相同，但新AOF文件**不会包含任何浪费空间**的冗余命令。

简单来说，就是新的AOF文件只会保存键值对的**最终状态的创建命令**。


> <br/>
>
> *面试官思考中…*
>
> <br/>

### 2.1 多条命令记录键值

> ***面试官：那照你这么说，只会保存创建命令，那每个键的创建只有一条命令对吧？***

噢噢不是的。这样的话在执行命令时可能会造成**客户端输入缓冲区**溢出。

所以Redis重写程序在处理列表、哈希表、集合、有序集合这四种可能会带有多个元素的键时，如果元素的数量超过了redis.h/REDIS_AOF_REWRITE_ITEMS_PER_CMD常量的值，那么重写程序将使用**多条命令**来记录键的值。

而不是一定就使用一条命令。

> <br/>
>
> *面试官思考中…*
>
> <br/>

### 2.2 处理新的创建请求

> ***面试官：那你说说AOF重写过程中，有新的创建请求进来怎么办？***

可以把这些新的创建请求写入到一个缓冲区里。

是这样，Redis服务器会维护一个**AOF重写缓冲区**，该缓冲区会在**子进程**创建新AOF文件期间，记录服务器执行的所有写命令。

等新的AOF文件创建完成，Redis服务器会将重写缓冲区中的所有内容**追加**到新AOF文件的末尾，来保证两个新旧AOF文件状态一致。

![在这里插入图片描述](https://img-blog.csdnimg.cn/direct/3cd6ca2787b04500b59a15738a705781.png#pic_center)

> *面试官抓抓脑袋，继续看你的简历......*
>
> <br/>
>
> *得想想考点你不懂的😰*

## 未完待续。。。
